# Thunderbird SDK — Multi-Sensor Device SDK (PoC)

A C++17 SDK for interfacing with a fused **LiDAR + IMU + Camera** sensor device.
This PoC focuses on **SDK infrastructure, data flow, and time synchronization** —
no AI/perception algorithms are included yet.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                        User Application                             │
│   on_lidar()  on_imu()  on_camera()  on_sync()                     │
└──────────┬──────────┬──────────┬──────────┬────────────────────────┘
           │          │          │          │
┌──────────▼──────────▼──────────▼──────────▼────────────────────────┐
│                      DeviceManager (public API)                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐   ┌───────────────────┐ │
│  │ LiDAR    │  │ IMU      │  │ Camera   │   │   SyncEngine      │ │
│  │ Driver   │  │ Driver   │  │ Driver   │──▶│ (nearest-neighbour│ │
│  │ (thread) │  │ (thread) │  │ (thread) │   │  time alignment)  │ │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘   └─────────┬─────────┘ │
│       │              │             │                    │           │
│  ┌────▼──────────────▼─────────────▼───┐     ┌─────────▼─────────┐ │
│  │       ITransport (abstract)         │     │   SyncBundle      │ │
│  │  SimulatedTransport │ USB │ Ethernet│     │ (LiDAR+IMU+Cam)  │ │
│  └─────────────────────────────────────┘     └───────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

### Key design decisions

| Decision | Rationale |
|---|---|
| **`shared_ptr<const T>` for all frames** | Zero-copy fan-out to user callbacks + sync engine; immutable after creation |
| **One thread per sensor driver** | Matches real hardware (independent I/O rates); avoids head-of-line blocking |
| **Lock-free `RingBuffer`** | SPSC pattern for high-throughput paths; drops oldest on overflow |
| **Nearest-neighbour sync** | Simple, deterministic, configurable tolerance — good enough for PoC |
| **PImpl in `DeviceManager`** | Stable ABI; hides internal headers from consumers |

---

## Repository Layout

```
thunderbird/
├── CMakeLists.txt                 # Top-level build (project version source-of-truth)
├── pyproject.toml                 # Python packaging (scikit-build-core + cibuildwheel)
├── .github/
│   └── workflows/
│       ├── ci.yml                 # CI on push/PR → build + test + deb smoke
│       └── release.yml            # Tag-triggered release pipeline (vX.Y.Z)
├── debian/                        # Debian packaging (Debian policy 4.6.2)
│   ├── changelog                  # Generated by scripts/update-changelog.sh
│   ├── control                    # Source + binary package definitions
│   ├── copyright                  # Machine-readable copyright (DEP-5)
│   ├── rules                      # debhelper 13 build rules (CMake)
│   ├── source/format              # 3.0 (native)
│   ├── libthunderbird-sdk0.install        # Runtime: .so.*
│   └── libthunderbird-sdk-dev.install     # Dev: headers, .a, .so, .pc, cmake
├── docker/
│   ├── Dockerfile.runtime         # Multi-stage: builder → minimal runtime (shared lib only)
│   └── Dockerfile.dev             # Multi-stage: builder → full dev (tools + SDK + source)
├── packaging/
│   └── build_deb.sh               # Quick .deb builder (legacy, non-policy)
├── scripts/
│   ├── extract-version.sh         # Version extraction utility (Git tag → X.Y.Z)
│   ├── generate-release-notes.sh  # Auto-changelog from conventional commits
│   └── update-changelog.sh        # Stamp debian/changelog from version
├── sdk/
│   ├── CMakeLists.txt             # Builds static + shared lib, install rules
│   ├── thunderbird-sdk.pc.in      # pkg-config template
│   ├── ThunderbirdSDKConfig.cmake.in  # CMake find_package() config template
│   ├── include/thunderbird/
│   │   ├── thunderbird.h          # Umbrella header
│   │   ├── version.h.in           # Version template (CMake configure_file)
│   │   ├── types.h                # Timestamp, data structs, enums
│   │   ├── transport.h            # ITransport interface
│   │   ├── simulated_transport.h  # Loopback transport
│   │   ├── sensor_driver.h        # ISensorDriver interface
│   │   ├── ring_buffer.h          # Lock-free SPSC ring buffer
│   │   ├── sync_engine.h          # Time-alignment engine
│   │   ├── device_manager.h       # Main public API
│   │   └── drivers/
│   │       ├── simulated_lidar.h
│   │       ├── simulated_imu.h
│   │       └── simulated_camera.h
│   └── src/
│       └── device_manager.cpp
├── examples/
│   ├── basic_streaming.cpp        # Connect + stream + print stats
│   ├── sync_demo.cpp              # Time-aligned bundle demo
│   └── raw_sensors.cpp            # Deep-dive into raw sensor data
├── tests/
│   ├── test_ring_buffer.cpp
│   ├── test_sync_engine.cpp
│   └── test_device_manager.cpp
├── python/
│   ├── CMakeLists.txt
│   ├── src/bindings.cpp           # pybind11 module
│   └── example.py                 # Python usage demo
└── ros2_bridge/
    ├── CMakeLists.txt
    ├── package.xml
    └── src/thunderbird_ros2_node.cpp
```

---

## Quick Start

### Prerequisites

- **C++17** compiler (GCC 9+, Clang 10+, MSVC 2019+)
- **CMake** ≥ 3.16
- *(Optional)* **pybind11** for Python bindings
- *(Optional)* **ROS 2 Humble/Iron** for the bridge node

### Build (simulated mode — no hardware needed)

```bash
# Clone
git clone <repo-url> thunderbird && cd thunderbird

# Configure + build
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --parallel

# Run tests
cd build && ctest --output-on-failure
```

### Run examples

```bash
./build/examples/basic_streaming
./build/examples/sync_demo
./build/examples/raw_sensors
```

### Build with Python bindings

```bash
pip install pybind11
cmake -B build -DTHUNDERBIRD_BUILD_PYTHON=ON
cmake --build build --parallel

# Run
cd python
PYTHONPATH=../build/python python example.py
```

### Build the ROS 2 bridge

```bash
# Inside a ROS 2 workspace
ln -s /path/to/thunderbird/ros2_bridge src/thunderbird_ros2_bridge
colcon build --packages-select thunderbird_ros2_bridge
source install/setup.bash
ros2 run thunderbird_ros2_bridge thunderbird_ros2_node
```

---

## C++ API Reference

### `DeviceManager` — primary entry point

```cpp
#include <thunderbird/thunderbird.h>

thunderbird::DeviceConfig cfg;
cfg.lidar_hz   = 10.0;   // LiDAR scan rate
cfg.imu_hz     = 200.0;  // IMU sample rate
cfg.camera_fps = 30.0;   // Camera frame rate

thunderbird::DeviceManager device(cfg);

// Register callbacks BEFORE start()
device.on_lidar([](std::shared_ptr<const thunderbird::LidarFrame> f) {
    // f->points, f->timestamp, f->sequence_number
});

device.on_imu([](std::shared_ptr<const thunderbird::ImuSample> s) {
    // s->accel, s->gyro, s->temperature, s->timestamp
});

device.on_camera([](std::shared_ptr<const thunderbird::CameraFrame> f) {
    // f->data (raw pixels), f->width, f->height, f->format
});

device.on_sync([](std::shared_ptr<const thunderbird::SyncBundle> b) {
    // b->lidar, b->imu, b->camera — time-aligned
});

device.connect();      // → Status::OK
device.start();        // begins streaming on sensor threads

// ... your processing loop ...

device.stop();
device.disconnect();
```

### Data types

| Type | Fields | Notes |
|---|---|---|
| `Timestamp` | `int64_t nanoseconds` | Steady-clock based; `.to_seconds()` helper |
| `LidarFrame` | `timestamp`, `points[]`, `sequence_number` | Each point: x/y/z/intensity/ring |
| `ImuSample` | `timestamp`, `accel[3]`, `gyro[3]`, `temperature` | SI units (m/s², rad/s, °C) |
| `CameraFrame` | `timestamp`, `width`, `height`, `format`, `data[]` | Raw pixel buffer |
| `SyncBundle` | `reference_time`, `lidar`, `imu`, `camera` | Any member may be `nullptr` |

### Sync configuration

```cpp
thunderbird::SyncConfig sync;
sync.tolerance_ns    = 50'000'000;  // 50 ms — max drift between sensors
sync.poll_interval_ms = 5;          // sync thread polling period
sync.reference_sensor = thunderbird::SensorType::LiDAR;

cfg.sync = sync;
```

---

## Time Synchronization — How It Works

```
Time ──────────────────────────────────────────────────────▶

LiDAR  ─── L1 ─────────────── L2 ─────────────── L3 ───
            10 Hz

IMU    ─ I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 ──
            200 Hz

Camera ──── C1 ─────── C2 ─────── C3 ─────── C4 ───────
            30 Hz

SyncEngine takes each LiDAR frame as reference and finds the
nearest IMU sample and Camera frame within ±tolerance_ns.

Bundle 1:  L1 + I_nearest + C_nearest
Bundle 2:  L2 + I_nearest + C_nearest
...
```

**Algorithm** (per sync cycle):
1. Pop the oldest unconsumed LiDAR frame → `ref_ts`
2. Search IMU queue for sample closest to `ref_ts` within tolerance
3. Search Camera queue for frame closest to `ref_ts` within tolerance
4. If Camera is available, emit `SyncBundle`; evict consumed data
5. If not, wait until next poll cycle

---

## CI/CD Architecture

The project uses two GitHub Actions workflows: **CI** (every push/PR) and **Release** (tag-triggered).

### CI Pipeline (`ci.yml`)

Runs on every push/PR to `main`/`develop`. Provides fast feedback via a build + test matrix:

| Runner | Build Type | Purpose |
|--------|-----------|---------|
| `ubuntu-24.04` | Release | Primary correctness gate |
| `ubuntu-24.04` | Debug | Assertion + sanitizer coverage |
| `ubuntu-24.04-arm` | Release | ARM64 platform verification |
Also includes:
- **Debian packaging smoke test** (Ubuntu 22.04 container, `dpkg-buildpackage`)
- **Python wheel smoke test** (`cibuildwheel` → manylinux2014, cp312, x86_64)
- **Docker smoke test** (builds runtime + dev images, verifies contents and tools)

CMake build caching ensures incremental rebuilds remain fast.

### Release Pipeline (`release.yml`)

Triggered **only** by semantic-version tags (`vX.Y.Z`). Four-stage pipeline:

```
┌────────────────────┐
│     preflight      │  extract version, validate tag, dedup guard,
│                    │  generate changelog from Git commits
└─────────┬──────────┘
          │
┌─────────▼──────────────────────────────────────────────┐
│            parallel build + test matrix                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ build-deb│  │build-whl │  │   test   │             │
│  │ x86 arm64│  │ x86 arm64│  │ x86 arm64│             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
└───────┼──────────────┼─────────────┼───────────────────┘
        │              │             │
┌───────▼──────────────▼─────────────▼───────────────────┐
│                    docker                               │
│   runtime + dev images (linux/amd64 + linux/arm64)      │
│   pushed to GHCR, signed with cosign (Sigstore OIDC)    │
└───────────────────────┬────────────────────────────────┘
                        │
┌───────────────────────▼────────────────────────────────┐
│                    release                              │
│   Create GitHub Release with auto-changelog             │
│   Attach .deb + .whl + SHA256SUMS                       │
│   Sign checksum blob with cosign (Sigstore OIDC)        │
└────────────────────────────────────────────────────────┘
```

#### Stage details

| Stage | Artifacts | Notes |
|-------|-----------|-------|
| **Preflight** | — | Parses `vX.Y.Z` tag, strict semver validation, verifies `CMakeLists.txt` version matches, rejects duplicate releases, generates changelog from conventional commits |
| **build-deb** | `libthunderbird-sdk0_X.Y.Z_{amd64,arm64}.deb`, `libthunderbird-sdk-dev_X.Y.Z_{amd64,arm64}.deb` | `dpkg-buildpackage` in Ubuntu 22.04 container; debhelper 13; Debian policy 4.6.2; lintian verified |
| **build-wheel** | `spatial_sdk-X.Y.Z-cp{39,310,311,312}-manylinux2014_{x86_64,aarch64}.whl` | `cibuildwheel` → PEP 599 manylinux2014 (glibc ≥ 2.17); auditwheel-repaired; static-libstdc++ |
| **test** | — | Full build + `ctest` on both architectures with simulated sensor backends |
| **docker** | `ghcr.io/<repo>-runtime:X.Y.Z`, `ghcr.io/<repo>-dev:X.Y.Z` | Multi-stage multi-arch builds via `buildx` + QEMU; semver tag hierarchy (`:X.Y.Z`, `:X.Y`, `:X`, `:latest`); GHA layer cache; manifest verification; cosign-signed with SBOM + provenance |
| **release** | GitHub Release page | Collects all `.deb` + `.whl`, generates `SHA256SUMS.txt`, signs with cosign, creates release with auto-generated changelog (categorized by conventional commit type), attaches all artifacts |

#### Auto-generated changelog

Release notes are generated automatically from Git history by `scripts/generate-release-notes.sh`:

- **Conventional commit parsing** — commits are categorized into Features, Bug Fixes, Performance, Refactoring, Documentation, Tests, CI/CD, Build, Maintenance
- **Previous tag detection** — finds the prior `vX.Y.Z` tag to compute the commit delta; falls back to initial commit for the first release
- **Artifacts table** — auto-detects `.deb`/`.whl` files with type, platform, Python version, and file size
- **Docker commands** — pre-filled `docker pull` + `cosign verify` instructions
- **Verification instructions** — SHA256 checksum verification + Sigstore cosign blob verification

#### Creating a release

```bash
# 1. Ensure CMakeLists.txt project(VERSION X.Y.Z) matches desired release
# 2. Use conventional commit messages: feat:, fix:, perf:, docs:, etc.
# 3. Tag and push:
git tag v1.2.3
git push origin v1.2.3

# The pipeline will automatically:
#   - Validate the tag & version match
#   - Build .deb packages (amd64 + arm64)
#   - Build Python wheels (cp39-cp312 × 2 arch)
#   - Run full test suite on both architectures
#   - Build & push Docker images to GHCR
#   - Create a GitHub Release with auto-generated changelog
#   - Sign all artifacts with cosign (Sigstore OIDC)
```

### Release Artifacts

A single tag push (`git tag v1.2.3 && git push --tags`) produces:

| Artifact | Format | Platforms |
|----------|--------|-----------|
| Debian runtime pkg | `libthunderbird-sdk0_*.deb` | amd64, arm64 |
| Debian dev pkg | `libthunderbird-sdk-dev_*.deb` | amd64, arm64 |
| Python wheels | `.whl` (manylinux2014) | x86_64, aarch64 × CPython 3.9–3.12 |
| Docker runtime image | OCI multi-arch | linux/amd64, linux/arm64 |
| Docker dev image | OCI multi-arch | linux/amd64, linux/arm64 |
| Checksums | `SHA256SUMS.txt` + `.sig` + `.cert` | — |

### Security & Signing

- **Cosign keyless signing** (Sigstore OIDC) — no secrets to manage, identity bound to the GitHub Actions workflow
- Docker images signed at the manifest digest level
- Checksum file signed as a blob; consumers verify with:

```bash
cosign verify-blob \
  --signature SHA256SUMS.txt.sig \
  --certificate SHA256SUMS.txt.cert \
  --certificate-identity-regexp "github.com/OWNER/thunderbird" \
  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
  SHA256SUMS.txt
```

### Docker Images

Two multi-arch images (linux/amd64 + linux/arm64) are published to GHCR on every release:

| Image | Base | Contents | Size |
|-------|------|----------|------|
| `thunderbird-runtime` | Ubuntu 24.04 | Shared library only (`.so.*`) | ~30 MB |
| `thunderbird-dev` | Ubuntu 24.04 | Headers, static + shared libs, pkg-config, CMake config, build tools, Python, source tree, tests | ~400 MB |

#### Tag strategy

Each release produces four tags per image:

```
ghcr.io/OWNER/thunderbird-runtime:1.2.3    # exact version
ghcr.io/OWNER/thunderbird-runtime:1.2      # minor track
ghcr.io/OWNER/thunderbird-runtime:1        # major track
ghcr.io/OWNER/thunderbird-runtime:latest   # latest stable
```

#### Pull & run

```bash
# Pull the minimal runtime image (shared lib only, non-root)
docker pull ghcr.io/OWNER/thunderbird-runtime:1.2.3

# Pull the full dev environment
docker pull ghcr.io/OWNER/thunderbird-dev:1.2.3

# Run the dev container interactively
docker run --rm -it ghcr.io/OWNER/thunderbird-dev:1.2.3
# Inside: gcc, cmake, python3, gdb, valgrind all available
# SDK pre-installed: pkg-config --cflags --libs thunderbird-sdk
```

#### Build locally

```bash
# Single-arch (native)
docker build --build-arg VERSION=0.1.0 \
  -f docker/Dockerfile.runtime -t thunderbird-runtime .

# Multi-arch (requires buildx)
docker buildx create --use
docker buildx build --platform linux/amd64,linux/arm64 \
  --build-arg VERSION=0.1.0 \
  -f docker/Dockerfile.runtime -t thunderbird-runtime .
```

#### Verify image signature

```bash
cosign verify \
  --certificate-identity-regexp "github.com/OWNER/thunderbird" \
  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
  ghcr.io/OWNER/thunderbird-runtime:1.2.3
```

#### Multi-stage Dockerfile architecture

Both images follow a two-stage pattern:

```
┌───────────────────────────────────────────┐
│  Stage 1: builder (Ubuntu 24.04)       │
│  • Full toolchain (gcc, cmake, etc.)   │
│  • Compile SDK from source              │
│  • Run tests (fail-fast)               │
│  • DESTDIR install → /staging/          │
└─────────────────────┴─────────────────────┘
                      │
          COPY --from=builder /staging/
                      │
┌─────────────────────┴─────────────────────┐
│  Stage 2: runtime or dev               │
│  runtime: shared .so.* only, non-root  │
│  dev: full SDK + toolchain + source    │
│  • ldconfig, HEALTHCHECK, OCI labels    │
└───────────────────────────────────────────┘
```

### Debian Packages

The SDK produces two Debian packages following Debian policy 4.6.2:

| Package | Contents | Install path |
|---------|----------|-------------|
| `libthunderbird-sdk0` | Shared library (`libthunderbird_sdk.so.0.*`) | `/usr/lib/<multiarch>/` |
| `libthunderbird-sdk-dev` | Headers, static lib (`.a`), dev symlink (`.so`), pkg-config, CMake config | `/usr/include/thunderbird/`, `/usr/lib/<multiarch>/` |

**Build locally:**

```bash
# Install build deps
sudo apt-get install build-essential cmake pkg-config debhelper devscripts

# Stamp the changelog (version from CMakeLists.txt)
./scripts/update-changelog.sh

# Build both .deb packages
dpkg-buildpackage -us -uc -b

# Packages appear in parent directory
ls ../*.deb
# libthunderbird-sdk0_0.1.0_amd64.deb
# libthunderbird-sdk-dev_0.1.0_amd64.deb
```

**Install and use:**

```bash
# Install runtime + dev
sudo dpkg -i ../libthunderbird-sdk0_*.deb ../libthunderbird-sdk-dev_*.deb

# Use via pkg-config
g++ my_app.cpp $(pkg-config --cflags --libs thunderbird-sdk) -o my_app

# Use via CMake
#   find_package(ThunderbirdSDK REQUIRED)
#   target_link_libraries(my_app PRIVATE Thunderbird::thunderbird_sdk_shared)
```

**debian/ directory layout:**

```
debian/
├── changelog                        # Stamped by CI from Git tag
├── control                          # Source + 2 binary packages
├── copyright                        # DEP-5 machine-readable
├── rules                            # debhelper 13 + CMake overrides
├── source/format                    # 3.0 (native)
├── libthunderbird-sdk0.install      # Runtime .so files
├── libthunderbird-sdk0.lintian-overrides
└── libthunderbird-sdk-dev.install   # Headers, .a, .so, .pc, cmake
```

### Python Wheels

The SDK publishes PEP 599-compliant **manylinux2014** wheels for CPython 3.9–3.12
on both x86_64 and aarch64:

| Wheel tag | Platform | Python | glibc |
|-----------|----------|--------|-------|
| `manylinux2014_x86_64` | x86_64 | cp39–cp312 | ≥ 2.17 |
| `manylinux2014_aarch64` | aarch64 | cp39–cp312 | ≥ 2.17 |

**Build pipeline:** scikit-build-core compiles the C++ SDK + pybind11 extension
inside the official PyPA manylinux2014 container (CentOS 7, devtoolset-12), then
`auditwheel repair` bundles any non-whitelisted shared libraries and applies the
correct platform tag. `libstdc++` is statically linked (`-static-libstdc++`) so
wheels work on any system with glibc ≥ 2.17.

```bash
# Install from release wheel (once published to PyPI or GH Release)
pip install spatial-sdk

# Build from source (requires C++ compiler + CMake ≥ 3.16)
pip install .

# Build wheels locally with cibuildwheel
pip install cibuildwheel
cibuildwheel --output-dir dist/

# Build a single wheel (useful for development)
pip wheel . --no-deps -w dist/
```

#### cibuildwheel configuration

All cibuildwheel settings live in `pyproject.toml` under `[tool.cibuildwheel]`.
Key settings:

```toml
[tool.cibuildwheel]
build = ["cp39-manylinux_*", "cp310-manylinux_*", "cp311-manylinux_*", "cp312-manylinux_*"]
manylinux-x86_64-image  = "manylinux2014"
manylinux-aarch64-image = "manylinux2014"

[tool.cibuildwheel.linux]
repair-wheel-command = [
    "auditwheel show {wheel}",
    "auditwheel repair --plat manylinux2014_$(uname -m) -w {dest_dir} {wheel}",
]
```

#### Auditwheel repair strategy

1. **Static libstdc++ / libgcc** — linked at build time via CMake (`-static-libstdc++ -static-libgcc`)
   so the extension has zero runtime dependency on the host's C++ ABI version
2. **`auditwheel show`** — logs the detected platform compatibility level (for CI traceability)
3. **`auditwheel repair --plat manylinux2014_*`** — bundles any remaining non-whitelisted `.so`
   files and stamps the correct `manylinux2014` platform tag on the wheel filename

---

## Versioning Strategy

**Single source of truth: Git tag** (`vX.Y.Z`). The version propagates to every
build artifact through a consistent injection pipeline.

### Version flow diagram

```
 Git tag (vX.Y.Z)
     │
     ├─► scripts/extract-version.sh ─► "X.Y.Z" string
     │       │
     │       ├─► CMake: -DTHUNDERBIRD_VERSION_OVERRIDE=X.Y.Z
     │       │       │
     │       │       ├─► version.h.in ──► version.h (compile-time macros)
     │       │       │       THUNDERBIRD_VERSION_STRING = "X.Y.Z"
     │       │       │       THUNDERBIRD_VERSION_MAJOR/MINOR/PATCH
     │       │       │
     │       │       └─► thunderbird::version() ─► runtime string
     │       │
     │       ├─► packaging/build_deb.sh ─► DEBIAN/control Version: X.Y.Z
     │       │
     │       ├─► cibuildwheel ─► CIBW_CONFIG_SETTINGS cmake.args=-D...
     │       │       └─► spatial_sdk wheel X.Y.Z
     │       │
     │       └─► Docker build-arg VERSION=X.Y.Z
     │               ├─► -DTHUNDERBIRD_VERSION_OVERRIDE=X.Y.Z
     │               └─► OCI label org.opencontainers.image.version
     │
     └─► GitHub Release tag = vX.Y.Z
```

### Extracting version from a Git tag

```bash
# scripts/extract-version.sh (included in this repo)
./scripts/extract-version.sh                # auto: tag → CMakeLists.txt fallback
./scripts/extract-version.sh --from-tag     # Git tag only
./scripts/extract-version.sh --from-cmake   # CMakeLists.txt only
./scripts/extract-version.sh --component major   # → "1"
./scripts/extract-version.sh --check-consistency # verify tag == CMakeLists.txt
```

Minimal inline snippet (used in CI preflight):

```bash
TAG="${GITHUB_REF_NAME}"        # e.g. v1.2.3
VER="${TAG#v}"                  # 1.2.3
MAJOR="${VER%%.*}"              # 1
REST="${VER#*.}"                # 2.3
MINOR="${REST%%.*}"             # 2
PATCH="${REST#*.}"              # 3
```

### CMake — compile-time version embedding

The root `CMakeLists.txt` accepts an optional override:

```cmake
# CI passes:  cmake -DTHUNDERBIRD_VERSION_OVERRIDE=1.2.3 ..
# Local dev:  uses project(VERSION 0.1.0) as fallback
if(DEFINED THUNDERBIRD_VERSION_OVERRIDE)
    set(PROJECT_VERSION "${THUNDERBIRD_VERSION_OVERRIDE}")
    # ... parse MAJOR.MINOR.PATCH into cache variables
endif()
```

`sdk/CMakeLists.txt` generates `version.h` from a template:

```cmake
configure_file(
    include/thunderbird/version.h.in
    ${CMAKE_CURRENT_BINARY_DIR}/include/thunderbird/version.h
    @ONLY
)
```

Producing macros usable in C++ code:

```cpp
#include <thunderbird/version.h>

static_assert(THUNDERBIRD_VERSION_AT_LEAST(1, 0, 0), "Need SDK ≥ 1.0.0");
printf("SDK %s\n", thunderbird::version());  // "1.2.3"
```

### Python — dynamic version resolution

The Python package resolves its version through a priority chain:

1. **`importlib.metadata`** — set automatically by scikit-build-core for installed wheels
2. **C++ extension `_spatial_sdk_core.THUNDERBIRD_VERSION`** — baked in via `version.h`
3. **Fallback** — `"0.0.0.dev0"` for editable/dev installs

`pyproject.toml` reads the fallback version from `CMakeLists.txt` via regex:

```toml
[tool.scikit-build.metadata.version]
provider = "scikit_build_core.metadata.regex"
input = "CMakeLists.txt"
regex = 'project\(.*VERSION (?P<value>[0-9]+\.[0-9]+\.[0-9]+)'
```

CI overrides with `CIBW_CONFIG_SETTINGS`:

```yaml
CIBW_CONFIG_SETTINGS: cmake.args=-DTHUNDERBIRD_VERSION_OVERRIDE=1.2.3
```

### Debian — version substitution

`packaging/build_deb.sh` accepts version as the first argument (or `auto`):

```bash
./packaging/build_deb.sh 1.2.3 amd64 build   # explicit
./packaging/build_deb.sh auto  amd64 build    # reads CMakeLists.txt
```

The script generates `DEBIAN/control` with `Version: ${VERSION}`.

### Docker — build-arg propagation

```dockerfile
ARG VERSION=0.1.0
RUN cmake ... -DTHUNDERBIRD_VERSION_OVERRIDE=${VERSION} ...
LABEL org.opencontainers.image.version="${VERSION}"
```

CI passes it via:

```yaml
build-args: VERSION=${{ needs.preflight.outputs.version }}
```

### Release checklist

To cut a release:

1. Update `CMakeLists.txt`: `project(thunderbird_sdk VERSION X.Y.Z ...)`
2. Commit: `git commit -am "release: vX.Y.Z"`
3. Tag: `git tag vX.Y.Z`
4. Push: `git push origin main --tags`
5. CI validates tag == CMakeLists.txt, builds all artifacts with version injected

---

## Implementation Plan (step-by-step)

### Phase 1 — Core infrastructure (this PoC) ✅
1. Define data types with dual timestamps (hardware + host)
2. Implement `ITransport` and `SimulatedTransport`
3. Build per-sensor driver interface + simulated backends
4. Implement lock-free `RingBuffer` for high-throughput paths
5. Build `SyncEngine` with nearest-neighbour alignment
6. Wire everything into `DeviceManager` with PImpl pattern
7. Add C++ examples and unit tests
8. Create ROS 2 bridge node (PointCloud2, Imu, Image publishers)
9. Add Python bindings via pybind11

### Phase 2 — Hardware integration (next)
- [ ] Implement real USB/Ethernet transport drivers
- [ ] Parse vendor-specific packet formats (LiDAR, IMU, Camera)
- [ ] Hardware PTP/PPS timestamp recovery
- [ ] Clock-offset estimation (linear regression on HW↔host timestamps)
- [ ] Reconnection / watchdog logic

### Phase 3 — Production hardening
- [ ] Configurable logging framework (spdlog)
- [ ] Thread-safe statistics / diagnostics endpoint
- [ ] CI pipeline (CMake presets, cross-compilation, sanitizers)
- [ ] API versioning & ABI stability guarantees
- [ ] Documentation generation (Doxygen)

### Phase 4 — Perception-ready extensions
- [ ] GPU-accelerated point cloud preprocessing
- [ ] Camera intrinsic / extrinsic calibration storage
- [ ] Multi-device support (multiple `DeviceManager` instances)
- [ ] Recording / playback (rosbag2 or custom binary format)

---

## License

MIT — see `LICENSE` for details.
